// ABOUTME: Example demonstrating frame-by-frame animation using Cairo image surfaces.
// ABOUTME: Generates a sequence of PNG frames showing a rotating hexagon and an orbiting ball.

package examples

import (
	"fmt"
	"math"
	"path/filepath"

	"github.com/mikowitz/cairo"
)

// AnimationFrameCount is the total number of frames generated by GenerateAnimation.
// At 30 frames per second this represents one second of animation.
//
// Frame rate considerations:
//   - Each frame is an independent 400×300 PNG written to disk
//   - To combine into a video: ffmpeg -r 30 -i frame_%03d.png animation.mp4
//   - Rendering is CPU-bound; batch-process frames sequentially or in parallel goroutines
//   - Memory per frame: 400×300×4 bytes ≈ 480 KB (freed after WriteToPNG)
const AnimationFrameCount = 30

// GenerateAnimation renders AnimationFrameCount PNG frames into outputDir.
// Frames are named frame_000.png through frame_029.png.
//
// Each frame shows:
//   - A dark background fading to deep blue
//   - A white hexagon rotating one full revolution across the sequence
//   - A colored ball orbiting the hexagon center
//
// To batch-process frames concurrently, callers can invoke generateAnimationFrame
// from multiple goroutines with non-overlapping frame indices.
func GenerateAnimation(outputDir string) error {
	for i := range AnimationFrameCount {
		t := float64(i) / float64(AnimationFrameCount) // progress 0.0 … <1.0
		path := filepath.Join(outputDir, fmt.Sprintf("frame_%03d.png", i))
		if err := generateAnimationFrame(path, t); err != nil {
			return fmt.Errorf("frame %d: %w", i, err)
		}
	}
	return nil
}

// generateAnimationFrame renders a single frame at animation progress t ∈ [0, 1)
// to outputPath as a PNG.
func generateAnimationFrame(outputPath string, t float64) error {
	const width, height = 400, 300

	surface, err := cairo.NewImageSurface(cairo.FormatARGB32, width, height)
	if err != nil {
		return fmt.Errorf("create surface: %w", err)
	}
	defer func() { _ = surface.Close() }()

	ctx, err := cairo.NewContext(surface)
	if err != nil {
		return fmt.Errorf("create context: %w", err)
	}
	defer func() { _ = ctx.Close() }()

	drawAnimationFrame(ctx, width, height, t)

	surface.Flush()
	if err := surface.WriteToPNG(outputPath); err != nil {
		return fmt.Errorf("write PNG: %w", err)
	}
	return nil
}

// drawAnimationFrame renders all visual elements for a frame at progress t.
func drawAnimationFrame(ctx *cairo.Context, w, h int, t float64) {
	cx, cy := float64(w)/2, float64(h)/2

	// Dark-to-deep-blue background gradient
	bg, _ := cairo.NewLinearGradient(0, 0, float64(w), float64(h))
	bg.AddColorStopRGB(0, 0.05, 0.05, 0.15)
	bg.AddColorStopRGB(1, 0.08, 0.12, 0.30)
	ctx.SetSource(bg)
	ctx.Paint()
	_ = bg.Close()

	// Rotating hexagon — completes one full revolution per sequence
	drawRotatingHexagon(ctx, cx, cy, 80, t*2*math.Pi)

	// Orbiting ball — travels one full orbit per sequence
	drawOrbitingBall(ctx, cx, cy, 120, t*2*math.Pi)
}

// drawRotatingHexagon draws a 6-sided polygon centered at (cx, cy) with the given
// radius, rotated by angle radians. The hexagon is filled white with a soft glow.
func drawRotatingHexagon(ctx *cairo.Context, cx, cy, r, angle float64) {
	ctx.Save()
	ctx.Translate(cx, cy)
	ctx.Rotate(angle)

	// Soft glow: semi-transparent larger hexagon underneath
	ctx.SetSourceRGBA(0.80, 0.85, 1.0, 0.12)
	hexPath(ctx, 0, 0, r*1.25, 6)
	ctx.Fill()

	// Solid hexagon fill
	ctx.SetSourceRGB(0.90, 0.92, 1.0)
	hexPath(ctx, 0, 0, r, 6)
	ctx.Fill()

	// Outline
	ctx.SetSourceRGBA(0.60, 0.70, 1.0, 0.80)
	ctx.SetLineWidth(2.5)
	hexPath(ctx, 0, 0, r, 6)
	ctx.Stroke()

	ctx.Restore()
}

// hexPath constructs a regular n-sided polygon path centered at (cx, cy).
func hexPath(ctx *cairo.Context, cx, cy, r float64, n int) {
	for i := range n {
		a := float64(i) * 2 * math.Pi / float64(n)
		x := cx + r*math.Cos(a)
		y := cy + r*math.Sin(a)
		if i == 0 {
			ctx.MoveTo(x, y)
		} else {
			ctx.LineTo(x, y)
		}
	}
	ctx.ClosePath()
}

// drawOrbitingBall draws a radial-gradient ball traveling around (cx, cy) at
// the given orbit radius and current angle.
func drawOrbitingBall(ctx *cairo.Context, cx, cy, orbitR, angle float64) {
	const ballR = 14.0
	bx := cx + orbitR*math.Cos(angle)
	by := cy + orbitR*math.Sin(angle)

	// Warm orange-to-red radial gradient for the ball
	grad, _ := cairo.NewRadialGradient(bx-ballR*0.35, by-ballR*0.35, 0, bx, by, ballR)
	grad.AddColorStopRGB(0, 1.0, 0.90, 0.55)
	grad.AddColorStopRGB(1, 0.85, 0.30, 0.10)
	ctx.SetSource(grad)
	ctx.Arc(bx, by, ballR, 0, 2*math.Pi)
	ctx.Fill()
	_ = grad.Close()

	// Subtle specular highlight
	ctx.SetSourceRGBA(1, 1, 1, 0.55)
	ctx.Arc(bx-ballR*0.30, by-ballR*0.30, ballR*0.28, 0, 2*math.Pi)
	ctx.Fill()
}
